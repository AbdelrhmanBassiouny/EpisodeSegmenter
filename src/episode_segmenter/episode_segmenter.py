import threading
import time
from abc import ABC, abstractmethod

from typing_extensions import List, Callable, Any, Type

from pycram.datastructures.world import World
from pycram.world_concepts.world_object import Object, Link

from .Events import ContactEvent, EventLogger, Event
from .EventDetectors import ContactDetector, LossOfContactDetector, PickUpDetector, EventDetector


class EpisodePlayer(threading.Thread, ABC):
    def __init__(self):
        super().__init__()
        self._ready = False

    @property
    def ready(self):
        return self._ready

    @abstractmethod
    def run(self):
        """
        The run method that is called when the thread is started. This should start the episode player thread.
        """
        pass


class EpisodeSegmenter(ABC):

    def __init__(self, episode_player: EpisodePlayer, detectors_to_start: List[EventDetector],
                 annotate_events: bool = False):
        """
        Initializes the EpisodeSegmenter class.
        :param episode_player: The thread that plays the episode and generates the motion.
        """
        self.episode_player: EpisodePlayer = episode_player
        self.detectors_to_start: List[EventDetector] = detectors_to_start
        self.logger = EventLogger(annotate_events)
        self.avoid_objects = ['particle', 'floor', 'kitchen']
        self.tracked_objects = []
        self.detector_threads = []
        self.pick_up_detectors = {}

    def start_motion_generator_thread_and_wait_till_ready(self) -> None:
        """
        Start the File player thread, and waits until the File player thread is
        ready (e.g., the replay environment is initialized with all objects in starting poses).
        """
        self.episode_player.start()
        while not self.episode_player.ready:
            time.sleep(0.1)

    def run_event_detectors(self) -> None:
        """
        Run the event detectors on the motion generated by the motion generator thread.
        """
        self.run_initial_event_detectors()

        while self.episode_player.is_alive() or self.logger.event_queue.unfinished_tasks > 0:

            thread_id, next_event = self.logger.get_next_event()

            if next_event is None:
                time.sleep(0.01)
                continue

            self.process_event(next_event)

        self.join()
        self.logger.print_events()

    @abstractmethod
    def process_event(self, event: Event) -> None:
        """
        Process the event generated by the event logger.
        """
        pass

    @abstractmethod
    def run_initial_event_detectors(self) -> None:
        """
        Run the initial event detectors on the motion generated by the motion generator thread.
        """
        pass

    def update_tracked_contacts(self, event: ContactEvent) -> None:
        """
        Update tracked contacts on trigger of a contact event by starting the contact threads for the object and the
         pickup thread for the object.

        :param event: The ContactEvent instance that represents the contact event.
        """
        objects_in_contact = event.contact_points.get_objects_that_have_points()
        obj_a = event.contact_points[0].link_a.object
        link_a = event.contact_points[0].link_a
        for obj_in_contact in objects_in_contact:
            if any([k in obj_in_contact.name.lower() for k in self.avoid_objects]):
                continue

            link_b = event.contact_points.get_links_in_contact_of_object(obj_in_contact)[0]

            if obj_in_contact not in self.tracked_objects:
                print(f"Creating new thread for object {obj_in_contact.name}")
                self.start_contact_threads_for_obj_and_update_tracked_objs(obj_in_contact)

            hand_link, obj_link = None, None
            if obj_a in hands and obj_in_contact not in hands:
                hand_link, obj_link = link_a, link_b
            elif obj_in_contact in hands and obj_a not in hands:
                hand_link, obj_link = link_b, link_a
            if hand_link is not None and obj_link is not None:
                self.start_detector_thread_for_starter_evnet(hand_link, obj_link)

    def start_contact_threads_for_obj_and_update_tracked_objs(self, obj: Object):
        """
        Start the contact threads for the object and updates the tracked objects.

        :param obj: The Object instance for which the contact threads are started.
        """
        for detector in (ContactDetector, LossOfContactDetector):
            detector_thread = detector(self.logger, obj)
            detector_thread.start()
            self.detector_threads.append(detector_thread)
        self.tracked_objects.append(obj)

    def start_detector_thread_for_starter_evnet(self, starter_event: Event,
                                                detector_type: Type[EventDetector]):
        """
        Start the detector thread for the given starter event.

        :param starter_event: The event that starts the detector thread.
        :param detector_type: The type of the detector.
        """
        if starter_event in self.detector_threads.keys():
            detector = self.detector_threads[starter_event]
            if detector.is_alive() or (detector.detected_before and detector.run_once):
                return
        detector = detector_type(starter_event, self.logger)
        detector.start()
        self.detector_threads[starter_event] = detector
        print(f"Created {detector_type.__name__} for starter event {starter_event}")

    def join(self):
        """
        Join all the threads.
        """
        self.episode_player.join()

        for detector_thread in self.detector_threads:
            detector_thread.exit_thread = True
            detector_thread.join()

        self.logger.join()


class HandBasedEpisodeSegmenter(EpisodeSegmenter):
    """
    The EpisodeSegmenter class is used to segment motions into activities (e.g. PickUp) and events by using
     event detectors such as contact, and loss of contact events.
    """

    def process_event(self, event: Event) -> None:
        if isinstance(event, ContactEvent):
            self.update_tracked_contacts(event)

    def run_initial_event_detectors(self) -> None:
        self.track_hand_contacts()

    def track_hand_contacts(self) -> None:
        """
        Start the contact threads for the hands.
        """
        hands = self.get_hands()
        for hand in hands:
            self.start_contact_threads_for_obj_and_update_tracked_objs(hand)

    @staticmethod
    def get_hands() -> List[Object]:
        """
        Get the hands from the world.

        :return: A list of Object instances that represent the hands.
        """
        return [obj for obj in World.current_world.objects if 'hand' in obj.name.lower()]
