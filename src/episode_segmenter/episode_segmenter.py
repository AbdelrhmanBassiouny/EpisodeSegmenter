import threading
import time
from abc import ABC, abstractmethod

import rospy
from typing_extensions import List, Type, Optional, Dict

from pycram.datastructures.dataclasses import ContactPointsList
from pycram.datastructures.enums import ObjectType
from pycram.datastructures.world import World, UseProspectionWorld
from pycram.world_concepts.world_object import Object
from pycram.object_descriptors.generic import ObjectDescription as GenericObjectDescription

from .event_detectors import ContactDetector, LossOfContactDetector, EventDetector, MotionDetector, \
    AbstractContactDetector
from .events import ContactEvent, Event, AgentContactEvent, PickUpEvent, EventUnion, StopMotionEvent, MotionEvent
from .event_logger import EventLogger
from .episode_player import EpisodePlayer


class EpisodeSegmenter(ABC):

    def __init__(self, episode_player: EpisodePlayer,
                 detectors_to_start: Optional[List[Type[EventDetector]]] = None,
                 annotate_events: bool = False):
        """
        Initializes the EpisodeSegmenter class.

        :param episode_player: The thread that plays the episode and generates the motion.
        :param detectors_to_start: The list of event detectors that should be started.
        :param annotate_events: A boolean value that indicates if the events should be annotated.
        """
        self.episode_player: EpisodePlayer = episode_player
        self.detectors_to_start: List[Type[EventDetector]] = detectors_to_start
        self.logger = EventLogger(annotate_events, [PickUpEvent, MotionEvent, StopMotionEvent])
        self.objects_to_avoid = ['particle', 'floor', 'kitchen']  # TODO: Make it a function, to be more general
        self.tracked_objects: List[Object] = []
        self.tracked_object_contacts: Dict[Object, List[Type[AbstractContactDetector]]] = {}
        self.tracked_object_motions: Dict[Object, MotionDetector] = {}
        self.detector_threads = {}
        self.pick_up_detectors = {}

    def start(self) -> None:
        """
        Start the episode player and the event detectors.
        """
        self.start_episode_player_and_wait_till_ready()
        self.run_event_detectors()

    def start_episode_player_and_wait_till_ready(self) -> None:
        """
        Start the Episode player thread, and waits until the thread signals that it is
        ready (e.g., the replay environment is initialized with all objects in starting poses).
        """
        self.episode_player.start()
        while not self.episode_player.ready:
            time.sleep(0.1)

    def run_event_detectors(self) -> None:
        """
        Run the event detectors on the motion generated by the motion generator thread.
        """
        self.run_initial_event_detectors()

        while self.episode_player.is_alive() or self.logger.event_queue.unfinished_tasks > 0:

            thread_id, next_event = self.logger.get_next_event()

            if next_event is None:
                time.sleep(0.01)
                continue

            self.process_event(next_event)

        self.join()
        self.logger.print_events()

    def process_event(self, event: EventUnion) -> None:
        """
        Process the event generated by the event logger, and start the detector threads that are triggered by the event.

        :param event: The event that should be processed.
        """
        self._process_event(event)
        self.start_triggered_detectors(event)

    def start_triggered_detectors(self, event: EventUnion) -> None:
        """
        Start the detector threads that are triggered by the event.

        :param event: The event that triggers the detector threads.
        """
        for event_detector in self.detectors_to_start:
            if event_detector.start_condition_checker(event):
                filtered_event = event_detector.filter_event(event)
                self.start_detector_thread_for_starter_event(filtered_event, event_detector)

    @abstractmethod
    def _process_event(self, event: Event) -> None:
        """
        Process the event generated by the event logger.

        :param event: The event that should be processed.
        """
        pass

    @abstractmethod
    def run_initial_event_detectors(self) -> None:
        """
        Run the initial event detectors on the episode played by the episode player thread.
        """
        pass

    def update_tracked_objects(self, event: EventUnion) -> None:
        """
        Update the tracked objects based on the event, for example a contact event would reveal new objects that should
        be tracked when an already tracked object comes into contact with a new object.

        :param event: The event that was triggered.
        """
        involved_objects = self.get_involved_objects(event)

        for obj in involved_objects:
            if self.avoid_object(obj):
                continue
            if obj not in self.tracked_objects:
                self.start_tracking_threads_for_new_object_and_event(obj, event)
                self.tracked_objects.append(obj)

    @abstractmethod
    def start_tracking_threads_for_new_object_and_event(self, new_object: Object, event: EventUnion):
        """
        Start the tracking threads for the new object, these threads are used to track the object's motion or contacts
         for example.

        :param new_object: The new object that should be tracked.
        :param event: The event that triggered the tracking.
        """
        pass

    @abstractmethod
    def get_involved_objects(self, event: EventUnion) -> List[Object]:
        """
        Get the objects involved in the event.

        :param event: The event that involves the objects.
        :return: A list of Object instances that are involved in the event.
        """
        pass

    def avoid_object(self, obj: Object) -> bool:
        """
        Check if the object should be avoided.

        :param obj: The object to check.
        :return: True if the object should be avoided, False otherwise.
        """
        return any([k in obj.name.lower() for k in self.objects_to_avoid])

    def start_motion_detection_threads_for_object(self, obj: Object) -> None:
        """
        Start the motion detection threads for the object.

        :param obj: The Object instance for which the motion detection threads are started.
        """
        detector_thread = MotionDetector(self.logger, obj)
        detector_thread.start()
        self.detector_threads[(obj, MotionDetector)] = detector_thread

    def start_contact_threads_for_object(self, obj: Object,
                                         event: Optional[ContactEvent] = None) -> None:
        """
        Start the contact threads for the object and updates the tracked objects.

        :param obj: The Object instance for which the contact threads are started.
        :param event: The ContactEvent instance that represents the contact event with the object.
        """
        if event is None:
            if obj.obj_type in [ObjectType.HUMAN, ObjectType.ROBOT]:
                event = AgentContactEvent(ContactPointsList([]), obj)
            else:
                event = ContactEvent(ContactPointsList([]), obj)
        for detector in (ContactDetector, LossOfContactDetector):
            detector_thread = detector(self.logger, obj)
            detector_thread.start()
            self.detector_threads[(event, detector)] = detector_thread
        self.tracked_object_contacts[obj] = [ContactDetector, LossOfContactDetector]

    def start_detector_thread_for_starter_event(self, starter_event: EventUnion,
                                                detector_type: Type[EventDetector]):
        """
        Start the detector thread for the given starter event.

        :param starter_event: The event that starts the detector thread.
        :param detector_type: The type of the detector.
        """
        if (starter_event, detector_type) in self.detector_threads.keys():
            detector = self.detector_threads[(starter_event, detector_type)]
            if detector.is_alive() or (detector.detected_before and detector.run_once):
                return
        detector = detector_type(self.logger, starter_event)
        detector.start()
        self.detector_threads[(starter_event, detector_type)] = detector
        rospy.logdebug(f"Created {detector_type.__name__} for starter event {starter_event}")

    def join(self):
        """
        Join all the threads.
        """
        self.episode_player.join()

        for detector_thread in self.detector_threads.values():
            detector_thread.exit_thread = True
            detector_thread.join()

        self.logger.join()


class AgentBasedEpisodeSegmenter(EpisodeSegmenter):
    """
    The AgentBasedEpisodeSegmenter class is used to segment motions into activities (e.g. PickUp) by tracking the
     events that are relevant to the agent for example contact events of the hands or robot.
    """

    def start_tracking_threads_for_new_object_and_event(self, new_object: Object, event: Optional[ContactEvent] = None):
        if new_object not in self.tracked_object_contacts:
            rospy.logdebug(f"Creating contact threads for object {new_object.name}")
            self.start_contact_threads_for_object(new_object, event)

    def get_involved_objects(self, event: ContactEvent) -> List[Object]:
        return event.contact_points.get_objects_that_have_points()

    def _process_event(self, event: Event) -> None:
        if isinstance(event, ContactEvent):
            self.update_tracked_objects(event)

    def run_initial_event_detectors(self) -> None:
        """
        Start the contact threads for the agents.
        """
        agents = self.get_agents()
        for agent in agents:
            self.start_contact_threads_for_object(agent)

    @staticmethod
    def get_agents() -> List[Object]:
        """
        :return: A list of Object instances that represent the available agents in the world.
        """
        return [obj for obj in World.current_world.objects if obj.obj_type in [ObjectType.HUMAN, ObjectType.ROBOT]]


class NoAgentEpisodeSegmenter(EpisodeSegmenter):
    """
    The NoAgentEpisodeSegmenter class is used to segment episodes into activities (e.g. PickUp) by tracking the
     events that are relevant to the objects in the world with the lack of an agent in the episode.
    """

    def start_tracking_threads_for_new_object_and_event(self, new_object: Object, event: EventUnion):
        # if new_object not in self.tracked_object_motions:
        #     rospy.logdebug(f"Creating motion threads for object {new_object.name}")
        #     self.start_motion_detection_threads_for_object(new_object)
        pass

    def get_involved_objects(self, event: EventUnion) -> List[Object]:
        # if isinstance(event, MotionEvent) or isinstance(event, StopMotionEvent):
        #     return [event.tracked_object]
        return []

    def _process_event(self, event: EventUnion) -> None:
        pass

    def run_initial_event_detectors(self) -> None:
        """
        Start the motion detection threads for the objects in the world.
        """
        for obj in World.current_world.objects:
            if obj.obj_type != ObjectType.ENVIRONMENT and (obj not in self.objects_to_avoid):
                self.start_motion_detection_threads_for_object(obj)
                self.detect_missing_support_for_object(obj)

    def detect_missing_support_for_object(self, obj: Object) -> None:
        """
        Detect if the object is not supported by any other object.

        :param obj: The object to check if it is supported.
        """
        supported = True
        with UseProspectionWorld():
            prospection_obj = World.current_world.get_prospection_object_for_object(obj)
            current_position = prospection_obj.get_position_as_list()
            World.current_world.simulate(1)
            new_position = prospection_obj.get_position_as_list()
            if current_position[2] - new_position[2] >= 0.01:
                rospy.logdebug(f"Object {obj.name} is not supported")
                supported = False
        if not supported:
            support = GenericObjectDescription(f"support_for_{obj.name}", [0, 0, 0], [1, 1, 0.005])
            support_obj = Object(f"support_for_{obj.name}", ObjectType.GENERIC_OBJECT, None, support)
            obj_position = obj.get_position_as_list()
            obj_position[2] -= 0.005
            support_obj.set_position(obj_position)
            self.start_contact_threads_for_object(support_obj)

